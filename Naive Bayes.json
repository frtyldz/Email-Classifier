{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 331,
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m~/opt/anaconda3/lib/python3.7/site-packages/pandas/io/parsers.py\u001b[0m in \u001b[0;36mread\u001b[0;34m(self, nrows)\u001b[0m\n\u001b[1;32m   2058\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 2059\u001b[0;31m             \u001b[0mdata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_reader\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnrows\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   2060\u001b[0m         \u001b[0;32mexcept\u001b[0m \u001b[0mStopIteration\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32mpandas/_libs/parsers.pyx\u001b[0m in \u001b[0;36mpandas._libs.parsers.TextReader.read\u001b[0;34m()\u001b[0m\n",
      "\u001b[0;32mpandas/_libs/parsers.pyx\u001b[0m in \u001b[0;36mpandas._libs.parsers.TextReader._read_low_memory\u001b[0;34m()\u001b[0m\n",
      "\u001b[0;32mpandas/_libs/parsers.pyx\u001b[0m in \u001b[0;36mpandas._libs.parsers.TextReader._read_rows\u001b[0;34m()\u001b[0m\n",
      "\u001b[0;32mpandas/_libs/parsers.pyx\u001b[0m in \u001b[0;36mpandas._libs.parsers.TextReader._convert_column_data\u001b[0;34m()\u001b[0m\n",
      "\u001b[0;32mpandas/_libs/parsers.pyx\u001b[0m in \u001b[0;36mpandas._libs.parsers.TextReader._convert_tokens\u001b[0;34m()\u001b[0m\n",
      "\u001b[0;32mpandas/_libs/parsers.pyx\u001b[0m in \u001b[0;36mpandas._libs.parsers.TextReader._convert_with_dtype\u001b[0;34m()\u001b[0m\n",
      "\u001b[0;32m~/opt/anaconda3/lib/python3.7/site-packages/pandas/core/dtypes/common.py\u001b[0m in \u001b[0;36mis_categorical_dtype\u001b[0;34m(arr_or_dtype)\u001b[0m\n\u001b[1;32m    677\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 678\u001b[0;31m \u001b[0;32mdef\u001b[0m \u001b[0mis_categorical_dtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marr_or_dtype\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    679\u001b[0m     \"\"\"\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: ",
      "\nDuring handling of the above exception, another exception occurred:\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-331-0e469c71429b>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     12\u001b[0m \u001b[0mtestFeatures\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread_csv\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"question-4-test-features.csv\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mheader\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     13\u001b[0m \u001b[0mtestLabels\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread_csv\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"question-4-test-labels.csv\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mheader\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 14\u001b[0;31m \u001b[0mtrainFeatures\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread_csv\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"question-4-train-features.csv\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mheader\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     15\u001b[0m \u001b[0mtrainLabels\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread_csv\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"question-4-train-labels.csv\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mheader\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/opt/anaconda3/lib/python3.7/site-packages/pandas/io/parsers.py\u001b[0m in \u001b[0;36mparser_f\u001b[0;34m(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, dialect, error_bad_lines, warn_bad_lines, delim_whitespace, low_memory, memory_map, float_precision)\u001b[0m\n\u001b[1;32m    683\u001b[0m         )\n\u001b[1;32m    684\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 685\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0m_read\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfilepath_or_buffer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkwds\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    686\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    687\u001b[0m     \u001b[0mparser_f\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__name__\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/opt/anaconda3/lib/python3.7/site-packages/pandas/io/parsers.py\u001b[0m in \u001b[0;36m_read\u001b[0;34m(filepath_or_buffer, kwds)\u001b[0m\n\u001b[1;32m    461\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    462\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 463\u001b[0;31m         \u001b[0mdata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mparser\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnrows\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    464\u001b[0m     \u001b[0;32mfinally\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    465\u001b[0m         \u001b[0mparser\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mclose\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/opt/anaconda3/lib/python3.7/site-packages/pandas/io/parsers.py\u001b[0m in \u001b[0;36mread\u001b[0;34m(self, nrows)\u001b[0m\n\u001b[1;32m   1152\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnrows\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1153\u001b[0m         \u001b[0mnrows\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_validate_integer\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"nrows\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnrows\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1154\u001b[0;31m         \u001b[0mret\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_engine\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnrows\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1155\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1156\u001b[0m         \u001b[0;31m# May alter columns / col_dict\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/opt/anaconda3/lib/python3.7/site-packages/pandas/io/parsers.py\u001b[0m in \u001b[0;36mread\u001b[0;34m(self, nrows)\u001b[0m\n\u001b[1;32m   2057\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnrows\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2058\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 2059\u001b[0;31m             \u001b[0mdata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_reader\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnrows\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   2060\u001b[0m         \u001b[0;32mexcept\u001b[0m \u001b[0mStopIteration\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2061\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_first_chunk\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "import os\n",
    "import csv\n",
    "import math\n",
    "import random\n",
    "import operator\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.image as mpimg\n",
    "\n",
    "testFeatures = pd.read_csv(\"question-4-test-features.csv\", header = None)\n",
    "testLabels = pd.read_csv(\"question-4-test-labels.csv\", header = None)\n",
    "trainFeatures = pd.read_csv(\"question-4-train-features.csv\", header = None)\n",
    "trainLabels = pd.read_csv(\"question-4-train-labels.csv\", header = None)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 296,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "undermining\n"
     ]
    }
   ],
   "source": [
    "trainWords = np.genfromtxt(\"question-4-vocab.txt\", dtype = str) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 335,
   "metadata": {},
   "outputs": [],
   "source": [
    "noWords = 37358\n",
    "lowestSpace = float('inf')\n",
    "highestSpace = float('-inf')\n",
    "lowestMedicine = float('inf')\n",
    "highestMedicine = float('-inf')\n",
    "lowestChrip = float('inf')\n",
    "highestChrip = float('-inf')\n",
    "lowestElec = float('inf')\n",
    "highestElec = float('-inf')\n",
    "\n",
    "def getVarNum():\n",
    "    #number of words arrays\n",
    "    spaceArr = np.zeros(noWords)\n",
    "    medicineArr = np.zeros(noWords)\n",
    "    chripArr = np.zeros(noWords)\n",
    "    elecArr = np.zeros(noWords)\n",
    "    testArr = testFeatures.to_numpy()\n",
    "    testLab = testLabels.to_numpy()\n",
    "    finArr = list()\n",
    "    \n",
    "    #number of essays in different classes\n",
    "    countSpace = 0\n",
    "    countElec = 0\n",
    "    countMedicine = 0\n",
    "    countChrip = 0\n",
    "    \n",
    "    for index, label in trainLabels.iterrows():\n",
    "        if(label[0] == 1):\n",
    "            countSpace += 1\n",
    "            spaceArr = np.array([spaceArr, trainFeatures.loc[index]]).sum(axis=0)\n",
    "        elif(label[0] == 0):\n",
    "            countMedicine += 1\n",
    "            medicineArr = np.array([medicineArr, trainFeatures.loc[index]]).sum(axis=0)\n",
    "        elif(label[0] == 2):\n",
    "            countChrip += 1\n",
    "            chripArr = np.array([chripArr, trainFeatures.loc[index]]).sum(axis=0)\n",
    "        elif(label[0] == 3):\n",
    "            countElec += 1\n",
    "            elecArr = np.array([elecArr, trainFeatures.loc[index]]).sum(axis=0)\n",
    "    \n",
    "    printMax20Words(spaceArr, medicineArr, chripArr, elecArr)\n",
    "    \n",
    "    for i in range(len(testArr)):\n",
    "        finArr.append(calculateParametersMAP(spaceArr, countSpace, medicineArr, countElec, chripArr, countMedicine, elecArr, countChrip, testArr[i]))\n",
    "    \n",
    "    print(\"Accuracy: \" + str(calc_accuracy(finArr, testLab)))\n",
    "    \n",
    "    #for i in range(len(testArr)):\n",
    "     #   finArr.append(calculateParametersMLE(spaceArr, countSpace, medicineArr, countElec, chripArr, countMedicine, elecArr, countChrip, testArr[i]))\n",
    "    \n",
    "   # print(\"Accuracy: \" + str(calc_accuracy(finArr, testLab)))   \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 337,
   "metadata": {},
   "outputs": [],
   "source": [
    "#part4.6 Calculation of max word\n",
    "def printMax20Words(spaceArr, medicineArr, chripArr, elecArr):\n",
    "    \n",
    "    sortedSpace = np.argsort(spaceArr)\n",
    "    sortedMedicine = np.argsort(medicineArr)\n",
    "    sortedChrip = np.argsort(chripArr)\n",
    "    sortedElec = np.argsort(elecArr)\n",
    "    finSpace = list()\n",
    "    finMedicine = list()\n",
    "    finChrip = list()\n",
    "    finElec = list()\n",
    "    \n",
    "    for index in range(noWords - 1, noWords - 21, -1):\n",
    "        finSpace.append(trainWords[sortedSpace[index]])\n",
    "        finMedicine.append(trainWords[sortedMedicine[index]])\n",
    "        finChrip.append(trainWords[sortedChrip[index]])\n",
    "        finElec.append(trainWords[sortedElec[index]])\n",
    "    \n",
    "    print(\"20 words common in Space----> \", finSpace, \"\\n\")\n",
    "    print(\"20 words common in Medicine----> \", finMedicine, \"\\n\")\n",
    "    print(\"20 words common in Chriptology----> \", finChrip, \"\\n\")\n",
    "    print(\"20 words common in Electronic----> \", finElec, \"\\n\")\n",
    "    \n",
    "    \n",
    "\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 327,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculateParametersMLE(spaceArr, countSpace, medicineArr, countElec, chripArr, countMedicine, elecArr, countChrip, testArr):\n",
    "    #word counts in classes\n",
    "    numSpace = np.array(spaceArr).sum()\n",
    "    numElec = np.array(elecArr).sum()\n",
    "    numMedicine = np.array(medicineArr).sum()\n",
    "    numChrip = np.array(chripArr).sum()\n",
    "    \n",
    "    #infinity check\n",
    "    chSpace = False\n",
    "    chElec = False\n",
    "    chMedicine = False\n",
    "    chChrip = False\n",
    "    \n",
    "    #essay numbers in classes\n",
    "    eSum = countSpace + countMedicine + countElec + countChrip\n",
    "    eSpace = countSpace/eSum\n",
    "    eElec = countElec/eSum\n",
    "    eMedicine = countMedicine/eSum\n",
    "    eChrip = countChrip/eSum\n",
    "    \n",
    "    #non zero elements\n",
    "    nonSpace = np.count_nonzero(spaceArr)\n",
    "    nonMedicine = np.count_nonzero(medicineArr)\n",
    "    nonElec = np.count_nonzero(elecArr)\n",
    "    nonChrip = np.count_nonzero(chripArr)\n",
    "        \n",
    "    #MLE estimators Space\n",
    "    probSpace = math.log(eSpace)    \n",
    "    for i in range(noWords):\n",
    "        if(spaceArr[i]/numSpace == 0 and testArr[i] == 0):\n",
    "            continue\n",
    "        else:\n",
    "            if(spaceArr[i]/numSpace == 0):\n",
    "                chSpace = True\n",
    "                break\n",
    "            logVal = np.log((spaceArr[i])/(numSpace))\n",
    "            probSpace += (logVal*testArr[i])\n",
    "            \n",
    "    #MLE estimators Medicine\n",
    "    probMedicine = math.log(eMedicine)\n",
    "    for i in range(noWords):\n",
    "        if(medicineArr[i]/numMedicine == 0 and testArr[i] == 0):\n",
    "            continue\n",
    "        else:\n",
    "            if(medicineArr[i]/numMedicine == 0):\n",
    "                chMedicine = True\n",
    "                break\n",
    "            logVal = np.log((medicineArr[i])/(numMedicine))\n",
    "            probMedicine += (logVal*testArr[i])\n",
    "\n",
    "            \n",
    "    #MLE estimators Electronic\n",
    "    probElec = math.log(eElec)\n",
    "    for i in range(noWords):\n",
    "        if(elecArr[i]/numElec == 0 and testArr[i] == 0):\n",
    "            continue\n",
    "        else:\n",
    "            if(elecArr[i]/numElec == 0):\n",
    "                chElec = True\n",
    "                break\n",
    "            logVal = np.log((elecArr[i])/(numElec))\n",
    "            probElec += (logVal*testArr[i])\n",
    "            \n",
    "    #MLE estimators Chriptology\n",
    "    probChrip = math.log(eChrip)\n",
    "    for i in range(noWords):\n",
    "        if(chripArr[i]/numChrip == 0 and testArr[i] == 0):\n",
    "            continue\n",
    "        else:\n",
    "            if(chripArr[i]/numChrip == 0):\n",
    "                chChrip = True\n",
    "                break\n",
    "            logVal = np.log((chripArr[i])/(numChrip))\n",
    "            probChrip += (logVal*testArr[i])\n",
    "    \n",
    "    if(chSpace and chMedicine and chElec and chChrip):\n",
    "        return 1\n",
    "    \n",
    "    if(probSpace>probMedicine and probSpace>probChrip and probSpace>probElec):\n",
    "        return 0\n",
    "    elif(probMedicine> probChrip and probMedicine>probElec and probMedicine>probSpace):\n",
    "        return 1\n",
    "    elif(probChrip>probSpace and probChrip>probMedicine and probChrip>probElec):\n",
    "        return 2\n",
    "    elif(probElec>probSpace and probElec>probMedicine and probElec>probChrip):\n",
    "        return 3\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 339,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculateParametersMAP(spaceArr, countSpace, medicineArr, countElec, chripArr, countMedicine, elecArr, countChrip, testArr):\n",
    "    \n",
    "    #lowest highest probability\n",
    "    global lowestSpace\n",
    "    global highestSpace\n",
    "    global lowestMedicine\n",
    "    global highestMedicine\n",
    "    global lowestElec\n",
    "    global highestElec\n",
    "    global lowestChrip\n",
    "    global highestChrip\n",
    "    \n",
    "    #word counts in classes\n",
    "    numSpace = np.array(spaceArr).sum()\n",
    "    numElec = np.array(elecArr).sum()\n",
    "    numMedicine = np.array(medicineArr).sum()\n",
    "    numChrip = np.array(chripArr).sum()\n",
    "    \n",
    "    #essay numbers in classes\n",
    "    eSum = countSpace + countMedicine + countElec + countChrip\n",
    "    eSpace = countSpace/eSum\n",
    "    eElec = countElec/eSum\n",
    "    eMedicine = countMedicine/eSum\n",
    "    eChrip = countChrip/eSum\n",
    "    \n",
    "    #non zero elements\n",
    "    nonSpace = np.count_nonzero(spaceArr)\n",
    "    nonMedicine = np.count_nonzero(medicineArr)\n",
    "    nonElec = np.count_nonzero(elecArr)\n",
    "    nonChrip = np.count_nonzero(chripArr)\n",
    "        \n",
    "    #MAP estimators Space\n",
    "    \n",
    "    probSpace = math.log(eSpace)    \n",
    "    for i in range(noWords):\n",
    "        logVal = math.log((spaceArr[i]+100)/(numSpace+(100*noWords)))\n",
    "        probSpace += (logVal*testArr[i])\n",
    "        if(lowestSpace > probSpace):\n",
    "            lowestSpace = probSpace\n",
    "        if(highestSpace < probSpace):\n",
    "            highestSpace = probSpace\n",
    "            \n",
    "    #MAP estimators Medicine\n",
    "    probMedicine = math.log(eMedicine)\n",
    "        \n",
    "    for i in range(noWords):\n",
    "        logVal = math.log((medicineArr[i]+100)/(numMedicine+(100*noWords)))\n",
    "        probMedicine += (logVal*testArr[i])\n",
    "        if(lowestMedicine > probMedicine):\n",
    "            lowestMedicine = probMedicine\n",
    "        if(highestMedicine < probMedicine):\n",
    "            highestMedicine = probMedicine\n",
    "            \n",
    "    #MAP estimators Electronic\n",
    "    probElec = math.log(eElec)\n",
    "        \n",
    "    for i in range(noWords):\n",
    "        logVal = math.log((elecArr[i]+100)/(numElec+(100*noWords)))\n",
    "        probElec += (logVal*testArr[i])\n",
    "        if(lowestElec > probElec):\n",
    "            lowestElec = probElec\n",
    "        if(highestElec < probElec):\n",
    "            highestElec = probElec\n",
    "            \n",
    "    #MAP estimators Chriptology\n",
    "    probChrip = math.log(eChrip)\n",
    "        \n",
    "    for i in range(noWords):\n",
    "        logVal = math.log((chripArr[i]+100)/(numChrip+(100*noWords)))\n",
    "        probChrip += (logVal*testArr[i])\n",
    "        if(lowestChrip > probChrip):\n",
    "            lowestChrip = probChrip\n",
    "        if(highestChrip < probChrip):\n",
    "            highestChrip = probChrip\n",
    "    \n",
    "    if(probSpace>probMedicine and probSpace>probChrip and probSpace>probElec):\n",
    "        return 1\n",
    "    elif(probMedicine> probChrip and probMedicine>probElec and probMedicine>probSpace):\n",
    "        return 0\n",
    "    elif(probChrip>probSpace and probChrip>probMedicine and probChrip>probElec):\n",
    "        return 2\n",
    "    elif(probElec>probSpace and probElec>probMedicine and probElec>probChrip):\n",
    "        return 3\n",
    "\n",
    "def calc_accuracy(gt_y, pred_y):\n",
    "    correct = 0\n",
    "    for g_y, p_y in zip(gt_y, pred_y):\n",
    "        if g_y == p_y: \n",
    "            correct += 1\n",
    "\n",
    "    return (correct/float(len(gt_y))*100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 340,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Most common 20 words in Space:  ['space', 'nasa', 'launch', 'earth', 'system', 'time', 'posting', 'orbit', 'moon', 'data', 'host', 'shuttle', 'people', 'net', 'spacecraft', 'satellite', 'solar', 'message', 'jpl', 'lunar'] \n",
      "\n",
      "Most common 20 words in Medicine:  ['medical', 'people', 'health', 'disease', 'patients', 'time', 'msg', 'food', 'cancer', 'hiv', 'well', 'years', 'treatment', 'posting', 'number', 'medicine', 'help', 'doctor', 'study', 'host'] \n",
      "\n",
      "Most common 20 words in Chriptology:  ['key', 'encryption', 'chip', 'government', 'clipper', 'people', 'system', 'keys', 'public', 'privacy', 'security', 'message', 'law', 'des', 'escrow', 'phone', 'time', 'nsa', 'data', 'secure'] \n",
      "\n",
      "Most common 20 words in Electronic:  ['power', 'ground', 'host', 'work', 'circuit', 'posting', 'time', 'wire', 'current', 'copy', 'message', 'radio', 'high', 'help', 'voltage', 'well', 'phone', 'problem', 'output', 'amp'] \n",
      "\n",
      "Accuracy: 75.75\n",
      "Lowest and highest probability of Space:  -19267.43348170366  and  -1.3862943611198906\n",
      "Lowest and highest probability of Medicine:  -19295.261257412883  and  -1.3862943611198906\n",
      "Lowest and highest probability of Chriptology:  -19031.80774203107  and  -1.3862943611198906\n",
      "Lowest and highest probability of Electronic:  -19358.233279576536  and  -1.3862943611198906\n"
     ]
    }
   ],
   "source": [
    "getVarNum()\n",
    "print(\"Lowest and highest probability of Space: \", lowestSpace, \" and \", highestSpace)\n",
    "print(\"Lowest and highest probability of Medicine: \", lowestMedicine, \" and \", highestMedicine)\n",
    "print(\"Lowest and highest probability of Chriptology: \", lowestChrip, \" and \", highestChrip)\n",
    "print(\"Lowest and highest probability of Electronic: \", lowestElec, \" and \", highestElec)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
